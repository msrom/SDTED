import networkx as nx
import random
import numpy as np
import time
import subprocess
import pandas as pd
import os
import matplotlib.pyplot as plt
import shutil
import csv
from collections import defaultdict


NAME_DS = "CUSTOM"
path_graphs = "SDTED/Data/" + NAME_DS + "/"

IDS_AS_TYPES= True
DICT_SHAPE_TYPE = {
    "ellipse": "file",
    "rectangle": "process",
    "diamond": "connection"
}

DICT_EDGE_TYPE = {
    "create": 0,
    "read": 1,
    "open": 2,
    "connect": 3,
    "send": 4, 
    "receive": 5,
    "write": 6,
    "execute": 7
}
    
DICT_NODE_TYPE = {
    "file": 0,
    "process": 1,
    "connection": 2
}

VERBOSE = False

###########################
# METRIC CALCULATIONS
###########################

def calc_f1_score(G_base, G_candidate):
    """
    Calculate the F1-score given precision and recall.
    
    Parameters:
    precision: Precision value (float)
    recall: Recall value (float)
    
    Returns:
    F1-score (float)
    """
    precision = calc_precision(G_base, G_candidate)
    recall = calc_recall(G_base, G_candidate)
    if precision + recall == 0:
        return 0.0
    
    return 2 * (precision * recall) / (precision + recall)


def calc_recall(G_base, G_candidate):
    """
    Calculate recall for node sets of two graphs.
    
    Parameters:
    G_base: Ground truth graph (networkx graph)
    G_candidate: Candidate graph generated by PIDS (networkx graph)
    
    Returns:
    Recall value (float)
    """
    set_G_base = [(node_id, G_base.nodes[node_id]) for node_id in G_base.nodes()]
    set_G_candidate = [(node_id, G_candidate.nodes[node_id]) for node_id in G_candidate.nodes()]

    common_nodes = intersection_lists(list(set_G_base), list(set_G_candidate))
    count_common_nodes = len(common_nodes)
    
    return count_common_nodes / len(G_base) if len(G_base) > 0 else 0.0


def calc_precision(G_base, G_candidate):
    """
    Calculate precision for node sets of two graphs.
    
    Parameters:
    G_base: Ground truth graph (networkx graph)
    G_candidate: Candidate graph generated by PIDS (networkx graph)
    
    Returns:
    Precision value (float)
    """
    
    set_G_base = [(node_id, G_base.nodes[node_id]) for node_id in G_base.nodes()]
    set_G_candidate = [(node_id, G_candidate.nodes[node_id]) for node_id in G_candidate.nodes()]
    
    common_nodes = intersection_lists(list(set_G_base), list(set_G_candidate))
    count_common_nodes = len(common_nodes)

    return count_common_nodes/len(G_candidate) if len(G_candidate) > 0 else 0.0


def intersection_lists(or_lst2, or_lst1):
    lst1 = or_lst1.copy()
    lst2 = or_lst2.copy()
    comm_list = []
    for i in or_lst1:
        if i in lst2:
            comm_list.append(i)
            lst1.remove(i)
            lst2.remove(i)
    return comm_list


###########################
# NEIGHBOR GRAPHS
###########################

def rename_node(G):
    # Select a random node
    random_node = random.choice(list(G.nodes))
    # Creates a random node name
    name_node = str(len(G.nodes()) + 1)
    # Checks if node name already exists in graph
    while name_node in G.nodes():
        name_node = str(int(name_node) + 1)
    nx.relabel_nodes(G, {random_node: name_node}, copy=False)
    G.nodes[name_node]["label"] = name_node
    if VERBOSE:
        print("Previous node: ", random_node)
        print("New node name: ", name_node)
    else:
        return "Changed label of node. Previous node name: " + random_node + " --> New node name: " + name_node

def change_edge(G):
    edge_to_remove = random.choice(list(G.edges))

    G.remove_edge(*edge_to_remove)

    nodes = list(G.nodes)
    new_edge = (random.choice(nodes), random.choice(nodes))

    while new_edge[0] == new_edge[1] or G.has_edge(*new_edge):
        new_edge = (random.choice(nodes), random.choice(nodes))

    type_e = random.sample(list(DICT_EDGE_TYPE.keys()), 1)[0]

    G.add_edge(*new_edge, action=type_e)

    if VERBOSE:
        print("Previous edge: (", str(edge_to_remove), ")")
        print("New edge: (", str(new_edge), ")")
    else:
        return "Changed edge. Previous edge: (" + str(edge_to_remove) + ") --> New edge: (" + str(new_edge) + ")"

def change_direction_edge(G):
    if len(G.edges()) > 0:
        # Select a random edge
        random_edge = random.choice(list(G.edges))
        # Remove the random edge
        act = nx.get_edge_attributes(G, "action")
        G.remove_edge(random_edge[0], random_edge[1])
        G.add_edge(random_edge[1], random_edge[0], action=act[(random_edge[0], random_edge[1])])
        
        if VERBOSE:
            print("Previous edge: (", random_edge[0], random_edge[1], ")")
            print("New edge: (", random_edge[1], ",", random_edge[0], ")")
        else:
            return "Changed direction of edge. Previous edge: (" + random_edge[0] + ', ' + random_edge[1] + ") --> New edge: (" + random_edge[1] + ", " + random_edge[0] + ")"

def delete_random_edge(G):
    if len(G.edges()) > 0:
     # Select a random edge
        random_edge = random.choice(list(G.edges))
        # Remove the random edge
        G.remove_edge(random_edge[0], random_edge[1])
        
        if VERBOSE:
            print("Removed edge: (", random_edge[0], random_edge[1], ")")
        else:
            return "Removed edge: ("+ random_edge[0] +', ' + random_edge[1] + ")"

def add_random_edge(G):
    # Select two random nodes
    random_edge = random.sample(list(G.nodes), 2)

    # Checks if edge already exists
    while G.has_edge(random_edge[0], random_edge[1]):
        random_edge = random.sample(list(G.nodes), 2)
    
    # Determines the random action
    type_e = random.sample(list(DICT_EDGE_TYPE.keys()), 1)[0]

    # Create the new edge
    G.add_edge(random_edge[0], random_edge[1], action=type_e)
    
    if VERBOSE:
        print("Created a new edge: (", random_edge[0], ",", random_edge[1], ")")
    else:
        return "Created a new edge: (" + random_edge[0] + "," + random_edge[1] + ")"

def add_random_node(G):
    # Creates a random node name
    name_node = str(len(G.nodes()) + 1)
    # Checks if node name already exists in graph
    while name_node in G.nodes():
        name_node = str(int(name_node) + 1)
    
    type_n = random.sample(list(DICT_SHAPE_TYPE.keys()), 1)[0]
    G.add_node(name_node, shape=type_n)
    if len(G.nodes()) > 0:
        node_source = random.sample(list(G.nodes), 1)[0]
        type_e = random.sample(list(DICT_EDGE_TYPE.keys()), 1)[0]
        G.add_edge(node_source, name_node, action=type_e)
        if VERBOSE:
            print("Created a new node: ", name_node, "connected with", node_source)
        else:
            return "Created a new node: " + name_node + " connected with " + node_source
    else:
        if VERBOSE:
            print("Created a new node: ", name_node, "(only node)")
        else:
            return "Created a new node: " + name_node + "(only node)"

def delete_random_node(G):
    if len(G.nodes()) > 0:
        # Select a random node
        random_node = random.choice(list(G.nodes))
        # Remove the random node
        G.remove_node(random_node)

        if VERBOSE:
            print("Removed node:", random_node)
        else:
            return "Removed node: " + random_node

def is_fully_connected(graph):
    """num_nodes = graph.number_of_nodes()
    if num_nodes <= 1:
        return True

    # The number of edges in a fully connected directed graph with n nodes is n * (n - 1) / 2
    expected_edges = num_nodes * (num_nodes - 1)
    return graph.number_of_edges() == expected_edges"""

    n = len(graph)                      
    if n <= 1:                       
        return True
    return all(
        len(set(graph.successors(u)) - {u}) == n - 1   
        for u in graph.nodes()
    )

def calculate_mutations_allowed(G, all_mutations):
    arr_mutations_allowed = all_mutations.copy()
    if is_fully_connected(G) or len(G.nodes()) <= 1:
        arr_mutations_allowed.remove(add_random_edge)
    if len(G.nodes()) <= 0:
        arr_mutations_allowed.remove(delete_random_node)
    if len(G.edges()) <= 0:
        arr_mutations_allowed.remove(delete_random_edge)
        arr_mutations_allowed.remove(change_direction_edge)
    return arr_mutations_allowed

def mute_graph(G, mutations_allowed, num_mutations=1):
    log_mutations = []
    for i in range(num_mutations):
        if VERBOSE:
            print(str(i) + "-th mutation")
        random.seed(time.time()*(i+1))
        calc_mutations_allowed = calculate_mutations_allowed(G, mutations_allowed)
        random_mutation = random.choice(calc_mutations_allowed)
        str_mut = random_mutation(G)
        log_mutations.append(str_mut)
    return G, log_mutations

def calc_depth_unfolding_tree(G_base):
    arr_nodes = []
    for node in G_base.nodes():
        path = nx.shortest_path(G_base, list(G_base.nodes())[0], node)
        if len(path) > len(arr_nodes):
            arr_nodes = path
    return len(arr_nodes)

# list_graphs must be an array of all the graphs that must be compared for getting distance matrixes
def write_SDTED_graphs(arr_graphs):
    # First of all, I have to perform a re-assignment of node ids, because with this methodology each node id is unique, even if they are from different graphs
    arr_graphs_aux = []
    # 1 because it has to start with 1 to correspond to the 1st line
    i = 1
    j = 1
    mapping = {}
    mapping_A = []
    type_dict = {} 
    # We use it to store the history of all ids correspondences
    mapping_inverse = {}  

    for index, graph in enumerate(arr_graphs):

        for node in graph.nodes():
            if node not in mapping.keys():
                mapping[node] = i
                mapping_inverse[i] = node
                d = nx.get_node_attributes(graph, "shape")
                type_dict[i] = DICT_SHAPE_TYPE[d[node]]
                i = i + 1
        H = nx.relabel_nodes(graph, mapping)
        if IDS_AS_TYPES:
            dict_graph = {}
            mapping_A.append({})
            for node in H.nodes():
                dict_graph[node] = node
                mapping_A[index][node] = j
                j = j + 1

            nx.set_node_attributes(H, dict_graph, name="type")
        arr_graphs_aux.append(H)

    arr_graphs = arr_graphs_aux   

    open(path_graphs + NAME_DS + "_graph_indicator.txt", "w")
    for index, graph in enumerate(arr_graphs):
        with open(path_graphs + NAME_DS + "_graph_indicator.txt", "a") as f:
            for node in graph.nodes():
                # Index must start with 1
                f.write(str(index + 1) + '\n')
    
    open(path_graphs + NAME_DS +"_A.txt", "w")
    for index, graph in enumerate(arr_graphs):
        with open(path_graphs + NAME_DS + "_A.txt", "a") as f:
            for edge in graph.edges():
                # The i-th node corresponds to the i-th row (starting with 1).
                f.write(str(mapping_A[index][edge[0]]) + ', ' + str(mapping_A[index][edge[1]]) + '\n')

    open(path_graphs + NAME_DS + "_edge_labels.txt", "w")
    for index, graph in enumerate(arr_graphs):
        with open(path_graphs + NAME_DS + "_edge_labels.txt", "a") as f:
            actions = nx.get_edge_attributes(graph, 'action')
            for edge in graph.edges():
                f.write(str(DICT_EDGE_TYPE[actions[(edge[0], edge[1])]]) + '\n')


    open(path_graphs + NAME_DS +"_node_labels.txt", "w")
    for index, graph in enumerate(arr_graphs):
        with open(path_graphs + NAME_DS + "_node_labels.txt", "a") as f:
            for node in graph.nodes():
                if IDS_AS_TYPES:
                    types = nx.get_node_attributes(graph, "type")
                    f.write(str(types[node]) + '\n')
                else:
                    shapes = nx.get_node_attributes(graph, "shape")
                    f.write(str(DICT_NODE_TYPE[DICT_SHAPE_TYPE[shapes[node]]]) + '\n')


    # New file type that stores the types of each id (to calculate the initial cost matrix)
    # The file consists of a dictionary separated with commas.  First col = id, second col = type
    if IDS_AS_TYPES:
        path_file = path_graphs + NAME_DS + "_node_types.txt"
        with open(path_file, "w") as f:
            for key_dict in type_dict.keys():
                f.write(str(key_dict) + ',' + str(DICT_NODE_TYPE[type_dict[key_dict]]) + '\n')
        
        path_file2 = path_graphs + NAME_DS + "_node_ids.txt"
        with open(path_file2, "w") as f:
            for key_dict in mapping_inverse.keys():
                f.write(str(key_dict) + ',' + str(mapping_inverse[key_dict]) + '\n')
    

    with open(path_graphs + NAME_DS + "_graph_labels.txt", "w") as f:
        for index, graph in enumerate(arr_graphs):
            f.write("1\n")

def extract_max_min_mean(data):
 
    max_min = {'Max': defaultdict(dict), 'Min': defaultdict(dict), 'Mean': defaultdict(dict)}
    
    for j in data[next(iter(data))]:              
        for met in data[next(iter(data))][j]:      
            valores = [data[i][j][met] for i in data if j in data[i]]
            max_min['Max'][j][met] = max(valores)
            max_min['Min'][j][met] = min(valores)
            max_min['Mean'][j][met] = sum(valores)/len(valores)
    
    return {k: dict(v) for k, v in max_min.items()}


###########################
# EFFICIENCY CALCULATION
###########################

def factorize(n):
    """ Returns all the possible combinations of two factors of n. """
    return [[i, n // i] for i in range(2, int(n**0.5) + 1) if n % i == 0]

def is_valid_graph(nodes, edges):
    """ Returns True if the number of edges is valid wrt the number 
    of nodes for generating a graph. """
    return edges <= (nodes * (nodes - 1)) // 2

def gen_graph(nodes, edges):
    """ Generates a connected graph with nodes nodes and edges edges. """
    G = nx.Graph()
    G.add_nodes_from(range(nodes))

    nodes_lista = list(range(nodes))
    for i in range(nodes - 1):
        G.add_edge(nodes_lista[i], nodes_lista[i + 1])

    posibles_edges = [(i, j) for i in range(nodes) for j in range(i + 1, nodes) if not G.has_edge(i, j)]
    random.shuffle(posibles_edges)
    
    for _ in range(edges - (nodes - 1)):  
        if posibles_edges:
            G.add_edge(*posibles_edges.pop())
    for node in G.nodes:
    # Add attributes
        type_n = random.sample(list(DICT_SHAPE_TYPE.keys()), 1)[0]

        G.nodes[node]["shape"] = type_n
    for edge in G.edges:
        type_e = random.sample(list(DICT_EDGE_TYPE.keys()), 1)[0]
        G.edges[edge]["action"] = type_e

    return G
